<?php
// $Id: gradebookapi.module,v 1.11.4.2.2.19 2010/08/20 02:59:26 mgn Exp $
/**
 * @file
 * An API for a simple gradebook.
 */

/**
 * Implements hook_views_api().
 */
function gradebookapi_views_api() {
  return array('api' => 2.0);
}

/**
 * Implements hook_perm().
 */
function gradebookapi_perm() {
  return array('admin gradebookapi');
}

/**
 * Implements hook_theme().
 */
function gradebookapi_theme() {
  return array(
    'gradebookapi_assignment_notice' => array('arguments' => array('node')),
  );
}

/**
 * Implements hook_menu().
 */
function gradebookapi_menu() {
  $items = array();
  $items['admin/gradebook'] = array(
    'title'            => 'Gradebook',
    'description'      => 'Administer the suite of Gradebook modules.',
    'position'         => 'left',
    'weight'           => -5,
    'page callback'    => 'system_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file'             => 'system.admin.inc',
    'file path'        => drupal_get_path('module', 'system'),
  );

  $items['admin/gradebook/gradebookapi'] = array(
    'title'            => 'Gradebook API',
    'description'      => 'Provides a gradebook API.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('gradebookapi_admin_settings'),
    'access callback'  => 'user_access',
    'access arguments' => array('administer site configuration'),
    'file'             => 'gradebookapi.admin.inc',
    'type' => MENU_NORMAL_ITEM, // optional
  );

  return $items;
}

/**
 * Implements hook_help().
 */
function gradebookapi_help($path, $arg) {
  switch ($path) {
    case 'admin/gradebook/gradebookapi':
      $output = '<p>'. t('The gradebook API provides a framework for developing gradebook user interfaces.') .'</p>';
      $output .= '<p>'. t('Indicate which of the following content types can be used as gradebook assignments. Their create content (add) forms will be given additional fields so the teacher can select the appropriate gradebook and to assign a possible number of points for the assignment.') .'</p>';
      return $output;
    case 'admin/gradebook':
      $output = '<p>'. t('The Gradebook suite of modules provides the framework and user interface for gradebooks that can be used by students and teachers. You can use the links below to configure these modules') .'</p>';
      return $output;
  }
}

/**
 * Implements hook_user().
 *
 * @return NONE
 */
function gradebookapi_user($op, &$edit, &$account, $category = NULL) {
  if (($op == 'register' && user_access('administer users')) ||
      ($op == 'form' && $category == 'account' && gradebookapi_is_student(NULL, $account))) {
    $form['gradebookapi'] = array(
      '#type' => 'fieldset',
      '#title' => t('Gradebook settings'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    $form['gradebookapi']['grade_update_email'] = array(
      '#title'          => t('Receive email notifications on grade update'),
      '#type'           => 'checkbox',
      '#default_value'  => $edit['grade_update_email'],
      '#description' => t('Check the box to receive emails notifying you when assignment grades are updated.'),
    );
    $form['gradebookapi']['assignment_update_email'] = array(
      '#title'          => t('Receive email notifications on assignment update'),
      '#type'           => 'checkbox',
      '#default_value'  => $edit['assignment_update_email'],
      '#description' => t('Check the box to receive emails notifying you when assignments are posted or modified.'),
    );
    return $form;
  }

  if ($op == 'delete' ) {
    drupal_set_message(t('Deleting gradebook grades for %name (uid %d) since account is being deleted',  array('%name' => $account->name, '%d' => $account->uid)));
    db_query("DELETE FROM {gradebookapi_grade} WHERE uid=%d", $account->uid);
    db_query("DELETE FROM {gradebookapi_cache} WHERE uid=%d", $account->uid);
    watchdog('gradebookapi', 'Deleted gradebook grades for %name (uid %d) upon deletion of account.', array('%name' => $account->name, '%d' => $account->uid), WATCHDOG_INFO);
  }
}

/**
 * Retrieves the content types used for gradebook assignments.
 *
 * @return 
 *   An array of content types that are used as gradebook assigments.
 */
function gradebookapi_get_assignment_types() {
  $vid = gradebookapi_get_vid();
  $vocabulary = taxonomy_vocabulary_load($vid); // returns vocabulary object
  return $vocabulary->nodes;
}

/**
 * Retrieves the gradebook taxonomy vocabulary id for gradebook terms (gradebooks and categories),
 * or creates one if it doesn't exist.
 *
 * @return
 *   The taxonomy vocabulary id for the gradebook.
 */
function gradebookapi_get_vid() {
  $vid = variable_get('gradebookapi_nav_vocabulary', '');
  if (empty($vid)) {
    // Check to see if a forum vocabulary exists
    $vid = db_result(db_query("SELECT vid FROM {vocabulary} WHERE module = '%s'", 'gradebook'));
    if (!$vid) {
      $edit = array(
        'name' => 'Gradebook',
        'description' => '',
        'help'        => '',
        'multiple' => 0,
        'required' => 1,
        'hierarchy' => 1,
        'relations' => 0,
        'module' => 'gradebook',
        'nodes' => array(),  // does this require an assignment type?
      );
      taxonomy_save_vocabulary($edit);
      $vid = $edit['vid'];
    }
    variable_set('gradebookapi_nav_vocabulary', $vid);
  }
  return $vid;
}

/**
 * Retreives the gradebook taxonomy term from a term id.
 *
 * @param $tid
 *   The gradebook term id.
 * @return
 *   The taxonomy term for the requested gradebook, or FALSE if it doesn't exist.
 */
function gradebookapi_gradebook_load($tid) {
  if (_gradebookapi_is_root_term($tid)) {
    return taxonomy_get_term($tid);
  }
  else {
    return FALSE;
  }
}

/**
 * Helper function that determines if a term id is the root of the taxonomy tree.
 *
 * @param $tid 
 *   The gradbook (or category) term id.
 * @return 
 *   TRUE if $tid is the root, FALSE if it has parents
 */
function _gradebookapi_is_root_term($tid) {
  $parents = taxonomy_get_parents($tid);
  if (!empty($parents)) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 * Gets the parent term (gradebook) for a child tid (assignment category).
 * @param $tid
 *   The $tid for a gradebook category.
 * @return
 *   The parent gradebook (taxonomy term) for the category.
 */
function gradebookapi_get_tid_gradebook($tid) {
  $parents = taxonomy_get_parents_all($tid);
  return array_pop($parents);
}

/**
 * Returns an array of all gradebooks.
 */
function gradebookapi_get_all_gradebooks() {
  $gradebooks = array();
  $vid = gradebookapi_get_vid();
  $result = db_query('SELECT DISTINCT t.tid FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE h.parent = 0 AND t.vid = %d', $vid);
  while ($tid = db_result($result)) {
    $gradebooks[] = gradebookapi_gradebook_load($tid);
  }
  return $gradebooks;
}

/**
 * Finds the gradebooks listing an assignment node.
 *
 * @param $node
 *   The assignment node.
 * @return
 *   An array of gradebook objects.
 */
function gradebookapi_assignment_get_gradebooks($node) {
  $gradebooks = array();
  $terms = gradebookapi_assignment_terms($node);
  foreach ($terms as $term) {
    if ($gradebook = gradebookapi_get_tid_gradebook($term->tid)) {
      $gradebooks[] = $gradebook;
    }
  }
  return $gradebooks;
}

/**
 *  Selects all the assignment nodes associated with a set of gradebook term ids. 
 *  Particularly useful for a Gradebook page that lists all assignments in a gradebook and their grades.
 *
 *  @param $gradebook
 *    the gradebook object
 *  @param $tids
 *    an array of term ids (gradebook categories) to use in the search. If empty, use all gradebook categories
 *  @param $operator
 *    Optional: default is 'or' which ... otherwise ...
 *  @param $depth
 *    Optional: if set extend the taxonomy tree accordingly, otherwise include only root terms ?
 *  @param $pager
 *    Optional: Default is TRUE, perform a paged database query, set to FALSE to do a limited range query instead.
 *  @param $order
 *    Optional:  use this to modify the query sort order. The default it Sticky DESC, Created DESC.
 *  @return
 *    Database query result.
 */
function gradebookapi_select_nodes($gradebook, $tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC') {
  $vid = gradebookapi_get_vid();
  $tree = taxonomy_get_tree($vid, $gradebook->tid);
  $allowed_tids = array_map('_taxonomy_get_tid_from_term', $tree);
  $allowed_tids[] = $gradebook->tid;
  $use_tids = array();

  if (!count($tids)) {
    // use all tids in gradebook
    $use_tids = $allowed_tids;
  }
  else {
    // make sure tids are only in gradebook
    foreach ($tids as $tid) {
      if (in_array($tid, $allowed_tids)) {
        $use_tids[] = $tid;
      }
    }
  }
//$tids[] = $gradebook->tid; // add in gradebook tid

  // taxonomy_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC')
  return _gradebookapi_select_nodes($use_tids, $operator, $depth, $pager, $order);
}

/**
 * Helper function to select assignment nodes affiliated with a set of gradebook categories.
 * @see gradebookapi_select_nodes()
 */
function _gradebookapi_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC') {
  if (count($tids) > 0 ) {

    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    foreach ($tids as $index => $tid) {

      if (is_numeric($tid)) {  // guard against null $tids...but what is the source of these?
        $term = taxonomy_get_term($tid);
        $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);
        $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));
      }
      else {
        unset($tids[$index]); // remove the offending $tid
      }
    }

    if ($operator == 'or') {
      $str_tids = implode(',', call_user_func_array('array_merge', $descendant_tids));
      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n INNER JOIN {term_node} tn ON n.nid = tn.nid INNER JOIN {term_data} td ON tn.tid = td.tid INNER JOIN {gradebookapi_assignment} a ON n.nid = a.nid WHERE tn.tid IN ('. $str_tids .') AND n.status = 1 ORDER BY '. $order;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {term_node} tn ON n.nid = tn.nid INNER JOIN {term_data} td ON tn.tid = td.tid INNER JOIN {gradebookapi_assignment} a ON n.nid = a.nid WHERE tn.tid IN ('. $str_tids .') AND n.status = 1';
    }
    else {
      $joins = 'INNER JOIN {gradebookapi_assignment} a ON n.nid = a.nid';
      $wheres = '';
      foreach ($descendant_tids as $index => $tids) {
        $joins .= ' INNER JOIN {term_node} tn'. $index .' ON n.nid = tn'. $index .'.nid INNER JOIN {term_data} td ON tn'. $index .'.tid = td.tid';
        $wheres .= ' AND tn'. $index .'.tid IN ('. implode(',', $tids) .')';
      }
      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres .' ORDER BY '. $order;
      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres;
    }
    $sql = db_rewrite_sql($sql);
    $sql_count = db_rewrite_sql($sql_count);
    if ($pager) {
      $result = pager_query($sql, variable_get('gradebook_grades_per_page', 10), 0, $sql_count);
    }
    else {
      $result = db_query($sql);  // get all records not a range 
    }
  }

  return $result;
}

/**
 * Retrieves the grade for the specified user and assignment. 
 *
 * @param $uid
 *   The user id to use in the request.
 * @param $nid
 *   The assignment node id to use in the request.
 * @return $grade
 *   The grade object.
 *   If more than one grade exists only the last query is returned. 
 *   If a grade has not been entered then a partial grade object with the possible value is returned.
 */
function gradebookapi_get_grade($uid, $nid) {
  $grades = gradebookapi_get_grades(array('uid' => $uid, 'nid' => $nid));
  if (count($grades)) {
    return array_pop($grades);
  }
  // if no grade exists, return grade with possible value
  else {
    $result = db_query('SELECT * FROM {gradebookapi_assignment} a WHERE a.nid=%d', $nid);
    $grade = db_fetch_object($result);
    $grade->uid = $uid;
    $grade->timestamp = 0; // use this to indicate that grade was not loaded from database
    return $grade;
  }
}

/**
 * Retrieves grade objects from the gradebookapi_grade and gradebookapi_assignment tables.
 *
 * @param $param
 *   an array of the form 'field' => $value to be used as the WHERE clause in an SQL query.
 *   Note: fields must be from gradebookapi_grade (uid, nid, earned, exempt, timestamp or note)
 * @return $grades
 *   an array of grade objects matching the constraint requested through $param.
 */
function gradebookapi_get_grades($param = array()) {
  $grades = array();

  foreach ($param as $key => $value) {
    $cond[] = 'g.'. db_escape_string($key) ." = '%s'";
    $arguments[] = $value;
  }
  $cond = implode(' AND ', $cond);
  // MN Removed a.sid....consequences? 
  $result = db_query('SELECT g.uid, g.nid, g.earned, g.exempt, a.possible, g.timestamp, g.note, a.due_date, a.publish_date FROM {gradebookapi_grade} g INNER JOIN {gradebookapi_assignment} a ON g.nid = a.nid WHERE '. $cond, $arguments);
  while ($grade = db_fetch_object($result)) {
    // can't use module_invoke here because it won't pass by reference..is there a better way to do this?
    $modules = module_implements('gradebookapi_grade');
    foreach ($modules as $module) {
      $func = $module.'_gradebookapi_grade';
      $func('get', $grade); //allows pass by reference!
    }
    $grades[] = $grade;
  }
  return $grades;
}

/**
 * Retrieves grade information by category and user from the gradebookapi_cache table.
 *
 * @param $uid
 *   The student user id
 * @param $tid
 *   The grade category term id
 * @return $grade
 *   A (partial) grade object
 */
function gradebookapi_get_term_grade($uid, $tid) {
  $result = db_query("SELECT uid, tid, earned, possible FROM {gradebookapi_cache} WHERE tid=%d AND uid=%d", $tid, $uid);
  $grade = db_fetch_object($result);

  return $grade;
}

/**
 * Updates or inserts the grade information into the gradebookapi_grade table.
 * The student's grades are then recalculated for each gradebook category.
 *
 * @param $grade
 *   The grade object.
 * @ return NONE
 */
function gradebookapi_set_grade($grade) {
  $old = gradebookapi_get_grade($grade->uid, $grade->nid);
  $grade->timestamp = time();
  if ($old->timestamp != 0) {
    db_query("UPDATE {gradebookapi_grade} SET exempt=%d, timestamp=%d, note='%s' WHERE uid=%d AND nid=%d", $grade->exempt, $grade->timestamp, $grade->note, $grade->uid, $grade->nid);
  } 
  else {
    db_query("INSERT INTO {gradebookapi_grade} (uid, nid, exempt, timestamp, note) VALUES (%d, %d, %d, %d, '%s')", $grade->uid, $grade->nid, $grade->exempt, $grade->timestamp, $grade->note);
  }

  if (is_numeric($grade->earned)) {  // trying to restore null status, rather than 0.
    db_query("UPDATE {gradebookapi_grade} SET earned = %f WHERE uid=%d AND nid=%d", $grade->earned, $grade->uid, $grade->nid);
  } 
  else {  // allow a grade to be returned to null status
    db_query("UPDATE {gradebookapi_grade} SET earned = NULL WHERE uid=%d AND nid=%d", $grade->uid, $grade->nid);
  }
  $node = node_load($grade->nid);
  $terms = taxonomy_node_get_terms_by_vocabulary($node, gradebookapi_get_vid());
  foreach ($terms as $term) {
    gradebookapi_calc_grades($grade->uid, $term->tid);
  } 
  $modules = module_implements('gradebookapi_grade');
  foreach ($modules as $module) {
    $func = $module.'_gradebookapi_grade';
    $func('set', $grade); //allows pass by reference!
  }
  
  gradebookapi_send_email('grade', array('assignment' => $node, 'grade' => $grade));

  if (module_exists('rules')) {
    $user = user_load(array('uid' => $grade->uid));
    rules_invoke_event('gradebookapi_set_grade', array('user' => $user, 'node' => &$node)); 
  }
}

/**
 * Recursively re-calculates grades for each gradebook category and its children.
 *
 * @param $tid
 *   The gradebook category term id (parent or child).
 *
 * @return NONE
 */
function gradebookapi_rebuild_grades($tid) {
  $children = taxonomy_get_children($tid, gradebookapi_get_vid());
  if ($children) {
    foreach ($children as $child) {
      gradebookapi_rebuild_grades($child->tid);
    }
  }
  else {
    gradebookapi_calc_term_grades($tid);
  }
}

/**
 * Deletes term grades from the gradebookapi_cache table.
 *
 * @param $tid
 *   The gradebook category term id  (parent or child).
 * @param $recursive
 *   If TRUE, then all child term grades are also deleted.
 * @param $start
 *   If TRUE, then term grades will be recalculated.
 *
 * @return NONE
 */
function gradebookapi_clear_term_grades($tid, $recursive = TRUE, $start = TRUE) {
  db_query("DELETE FROM {gradebookapi_cache} WHERE tid=%d", $tid);
  // do a recursive delete?
  if ($recursive) {
    $children = taxonomy_get_children($tid, gradebookapi_get_vid());
    foreach ($children as $child) {
      gradebookapi_clear_term_grades($child->tid, $recursive, FALSE);
    }
  }
  // tell parents to recalc cache
  if ($start) {
    $parents = taxonomy_get_parents($tid);
    foreach ($parents as $parent) {
      gradebookapi_calc_term_grades($parent->tid);
    }
  }
}

/**
 * Calculates the student grade for a given gradebook category.
 *
 * @param $tid
 *   The gradebook category term id (parent or child).
 * @param $uid
 *   The student user id, if its < 1, then all grades are calculated.
 * @param $recursive
 *   If TRUE, then calc grades for all gradebook category child terms.
 *
 * @return NONE
 */
function gradebookapi_calc_grades($uid, $tid, $recursive=TRUE) {
  $gradebook = gradebookapi_get_tid_gradebook($tid);
  // if UID is < 1, calc grades for ALL users
  if ($uid<=0) {
    return gradebookapi_calc_term_grades($tid);
  }
  else {
    // clear cache
    db_query("DELETE FROM {gradebookapi_cache} WHERE tid=%d AND uid=%d", $tid, $uid);

    // get grades from child terms
    $earned = 0;
    $possible = 0;
    $children = taxonomy_get_children($tid, gradebookapi_get_vid());
    foreach ($children as $child) {
      $grade = gradebookapi_get_term_grade($uid, $child->tid);
      if ($grade && !is_null($grade->earned) &&  !$grade->exempt) {
        $earned += $grade->earned;
        $possible += $grade->possible;
      }
    }
    // get grades from nodes at this term
    $catearned = 0;   // earned grade at this term
    $catpossible = 0; // possible points at this term
    $result = gradebookapi_select_nodes($gradebook, array($tid), 'or', 0, FALSE);
    while ($assignment = db_fetch_object($result)) {
      $grade = gradebookapi_get_grade($uid, $assignment->nid);
      if ($grade && !is_null($grade->earned) && !$grade->exempt) {
        $catearned += $grade->earned;
        $catpossible += $grade->possible;
      }
    }
    $weighted_grade = gradebookapi_weight_grade($gradebook->tid, $tid, $catpossible, $catearned);
    $earned += $weighted_grade['earned'];
    $possible += $weighted_grade['possible'];
   // cache grade
    db_query("INSERT INTO {gradebookapi_cache} (uid, tid, earned, possible) VALUES (%d, %d, %f, %f)", $uid, $tid, $earned, $possible);

    if ($recursive) {
      // recalc parents
      $parents = taxonomy_get_parents($tid);
      foreach ($parents as $parent) {
        gradebookapi_calc_grades($uid, $parent->tid, $recursive);
      }
    }
  }
}

/**
 * Provides a hook to weight the grade.
 *
 * If more than one module uses this hook, what to do with the several weights?
 * Avoid this by just popping one module name from the list of modules that implement.
 *
 * @param $gid
 *   The gradebook taxonomy (root) term id.
 * @param $tid
 *   The gradebook category.
 * @param $catpossible
 *   The possible points for the category.
 * @param $catearned
 *   The earned points for the category.
 *
 * @return 
 *   Associative array with keys 'earned' and 'possible' for the weighted earned and possible grades.
 */
function gradebookapi_weight_grade($gid, $tid, $catpossible, $catearned) {
  $modules = module_implements('gradebookapi_weighted_grade');
  $module = array_pop($modules);
  return ($module) ?  module_invoke($module,'gradebookapi_weighted_grade', $gid, $tid, $catpossible, $catearned) : array('earned' => $catearned, 'possible' => $catpossible);
}

/**
 * Provides a hook to let other modules specify the category weighting used by hook_gradebookapi_weighted_grade.
 *
 * @param $gid
 *   The gradebook taxonomy (root) term id.
 *
 * @return
 *
 */
function gradebookapi_get_weights($gid) {
  $modules = module_implements('gradebookapi_get_gradebook_weights');
  $module = array_pop($modules);
  return ($module) ?  module_invoke($module,'gradebookapi_get_gradebook_weights', $gid) : array();
}

/**
 * Calculates all student grades for a gradebook or gradebook category.
 *
 * @param $tid
 *   The taxonomy term id to use to lookup grades on associated assignment nodes.
 * @param $recursive
 *   If TRUE (default), then all gradebook category child terms are also calculated.
 *
 * @return NONE
 */
function gradebookapi_calc_term_grades($tid, $recursive=TRUE) {
  $gradebook = gradebookapi_get_tid_gradebook($tid);
  $students = gradebookapi_get_students($gradebook);
  if ($str_uids = implode(',', $students['uid'])) {
    $result = db_query("SELECT u.uid FROM {users} u WHERE u.status <> 0 AND u.uid IN (". $str_uids .") ORDER BY u.name ASC");
  }
  else {
    $result = FALSE;
  }
  if ($result) {
    while ($account = db_fetch_object($result)) {
      gradebookapi_calc_grades($account->uid, $tid, $recursive);
    }
  }
}

/**
 * Calculates the student grades for a given set of gradebook categories associated with an assignment.
 *
 * @param $node
 *   The assignment node 
 * @param $terms
 *   An array of gradebook category terms to calculate the grade for.
 *   If empty, then grades will be calculated for all categories.
 *
 * @return NONE
 */
function gradebookapi_calc_assignment_grades($node, $terms = array()) {

  if (empty($terms)) {
    $terms = taxonomy_node_get_terms_by_vocabulary($node, gradebookapi_get_vid());
  }
  foreach ($terms as $term) {
    gradebookapi_calc_term_grades($term->tid);
  }
}

/**
 * Implements hook_taxonomy().
 */
function gradebookapi_taxonomy($op, $type, $obj = NULL) {
  if ($obj['vid'] == gradebookapi_get_vid()) {
    switch ($op) {
      case 'delete':
        switch ($type) {
          case 'term':
            // TODO: by the time we get here, the hierarchy has already been cleaned.
            //       how do we tell the parent to recalc?
            gradebookapi_clear_term_grades($obj['tid']);
            // TODO: delete nodes associated with this term and it's children
            break;
          case 'vocabulary':
            variable_del('gradebookapi_nav_vocabulary');
            break;
        }
        break;
    }
  }
}

/**
 * Retrieves all of the gradebook taxonomy terms associated with a node.
 *
 * @param $node
 *   The assignment node.
 *
 * @return
 *   An array of gradebook taxonomy terms.
 */
function gradebookapi_assignment_terms($node) {
  $terms = array();
  $vid = gradebookapi_get_vid();
  $allterms = taxonomy_node_get_terms($node);

  foreach ($allterms as $term) {
    // make sure we only look in the gradebook vocabulary
    if ($term->vid == $vid) {
      $terms[] = $term;
    }
  }
  return $terms;
}

/**
 * Retrieves the additional form fields from the gradebookapi_assignment database table.
 *
 * These fields will be added to assignment create node form.
 * Called via hook_nodeapi (load).
 * @param $node
 *   The assignment node.
 *
 * @return
 *   An array of form default values.
 */
function gradebookapi_assignment_load($node) {
  $additions = db_fetch_array(db_query('SELECT possible, publish_date, due_date FROM {gradebookapi_assignment} WHERE nid = %d', $node->nid));
  return $additions;
}

/**
 * Inserts additional assignment fields into the gradebookapi_assignment database table.
 *
 * The grades are then recalculated since the possible value, etc. may have changed.
 *   Called via hook_nodeapi (insert).
 * @param $node
 *   The assignment node.
 *
 * @return NONE
 */
function gradebookapi_assignment_insert($node) {
  require_once('gradebook.datetime.inc');

  if (_gradebookapi_usedateapi()) {
    $node->publish_date = _gradebookapi_datepopup2unixtime($node->publish_date);
    $node->due_date = _gradebookapi_datepopup2unixtime($node->due_date);
  }
  else {
    $node->publish_date = _gradebookapi_drupaldate2unixtime($node->publish_date);
    $node->due_date = _gradebookapi_drupaldate2unixtime($node->due_date);
  }

  $now = time();
  $node->status =  ($now > $node->publish_date) ? 1 : 0;

  // This assumes that gradebookapi has a lighter weight than any submodules so it is called first.
  db_query("INSERT INTO {gradebookapi_assignment} (nid, possible, publish_date, due_date) VALUES (%d, %f, '%d', '%d')", $node->nid, $node->possible, $node->publish_date, $node->due_date);

  // we have to manually update terms as we can't control module order
  taxonomy_node_save($node, $node->taxonomy);
  gradebookapi_calc_assignment_grades($node);
}

/**
 * Updates additional assignment fields in the gradebookapi_assignment database table when the node is updated.
 *
 *  The grades are then recalculated since the possible value, etc. may have changed.
 *  Called via hook_nodeapi (update).
 *
 *  @param $node
 *    the assignment node.
 *
 *  @return NONE
 */
function gradebookapi_assignment_update(&$node) {
  require_once('gradebook.datetime.inc');

  if (_gradebookapi_usedateapi()) {
    $node->publish_date = _gradebookapi_datepopup2unixtime($node->publish_date);
    $node->due_date = _gradebookapi_datepopup2unixtime($node->due_date);
  }
  else {
    $node->publish_date = _gradebookapi_drupaldate2unixtime($node->publish_date);
    $node->due_date = _gradebookapi_drupaldate2unixtime($node->due_date);
  }
  if (gradebookapi_is_assignment_node($node)) {
    db_query("UPDATE {gradebookapi_assignment} SET possible = '%s', publish_date = '%d', due_date = '%d' WHERE nid = %d", $node->possible, $node->publish_date, $node->due_date, $node->nid); 
  }
  else { // assignment doesn't exist in gradebookapi_assignment table, so insert it
    gradebookapi_assignment_insert($node);
  }

  // We have to manually update terms as we can't control module order.

  taxonomy_node_save($node, $node->taxonomy);

  gradebookapi_calc_assignment_grades($node);

  //if the term has changed, clear the term grade for the previous term.

  $tax = $node->taxonomy;
  $index = gradebookapi_get_vid();
  if ((isset($node->oldtid) && isset($tax[$index]) && $tax[$index] != $node->oldtid )) {
    gradebookapi_calc_term_grades($node->oldtid);
  }

  gradebookapi_send_email('assignment', array('assignment' => $node));

}

/**
 * Deletes assignment field values from the gradebookapi_assignment database table when the node is deleted.
 * The grades are then recalculated.
 * Called via hook_nodeapi (delete).
 *
 *  @param $node
 *    The assignment node.
 *
 *  @return NONE
 */
function gradebookapi_assignment_delete($node) {
  // Delete records for all students for this assignment node.
  db_query('DELETE FROM {gradebookapi_assignment} WHERE nid = %d', $node->nid);
  // Delete grades for all users for this assignment node.
  db_query('DELETE FROM {gradebookapi_grade} WHERE nid = %d', $node->nid);

  // If taxonomy_node_delete has already been called, then we loose the info in
  // {term_node} needed to recalculate the grade instead, gather the gradebook api
  // terms associated with an assignment and send them into gradebookapi_calc_grades
  // to bypass the call to taxonomy_node_get_terms_by_vocabulary() (which will fail).
  $allterms = $node->taxonomy;
  $vid = gradebookapi_get_vid();
  $terms= array();
  foreach ($allterms as $term) {
    if ($term->vid == $vid) {
      $terms[$term->tid] = $term;
    }
  }
  gradebookapi_calc_assignment_grades($node, $terms);
}

/**
 * Adds assignment field values to $node->content before rendering.
 * Called via hook_nodeapi (view).
 *
 *  @param $node
 *    The assignment node.
 *  @param $teaser
 *    The teaser parameter passed from node_view().
 *  @param $page
 *    The page parameter passed from node_view().
 *
 *  @return NONE
 */
function gradebookapi_assignment_view(&$node, $teaser = FALSE, $page = FALSE) {
  $node->content['assignment_notice'] = array(
    '#value' => theme('gradebookapi_assignment_notice', $node),
    '#weight' => -100,
  );
}

/**
 * Determines if the node is an assignment node.
 *
 * @param $node
 *   The assignment node.
 *
 * @return
 *   TRUE if the node is an assignment node, FALSE otherwise.
 */
function gradebookapi_is_assignment_node($node) {
  $count = db_result(db_query('SELECT COUNT(nid) FROM {gradebookapi_assignment} WHERE nid = %d', $node->nid));
  return ($count >0);
}

/**
 * Provides a notice with assignment information on the assignment node. 
 *
 * @param $node
 *   The assignment node.
 *
 * @return
 *   The HTML string ready to display.
 */
function theme_gradebookapi_assignment_notice($node) {
  global $user;
  $account = user_load(array('uid' => $user->uid));
  // Retrieve gradebook name and assignment category.
  $terms = gradebookapi_assignment_terms($node);
  // Collects gradebook name and category name for this assignment
  $gnames = array();
  $categories = array();
  foreach ($terms as $term) {
    // Retrieves the gradebook for this term and checks to see if the user in the gradebook.
    $gradebook = gradebookapi_get_tid_gradebook($term->tid);
    if (gradebookapi_is_student_or_teacher($gradebook, $account) && ($term->tid != $gradebook->tid)) {
      $gnames[$term->tid] = $gradebook->name;
      $categories[$term->tid] = $term->name;
    }
  }
  $output = '';
  if (!empty($gnames)) {
    $output = '<div class = "gradebook-assignment-notice">';
    $output .= '<ul class = "gradebook-assignment-category">';
    foreach ($categories as $tid => $category) {
      $output .= '<li>';
      $output .= t('@category Assignment for @course', array('@category' => $category, '@course' => $gnames[$tid]));
      $output .= '</li>';
    }
    $output .= '</ul>';

    if (isset($node->possible)) {
      $output .= '<p>';
      $output .= '<span class = "gradebook-assignment-possible">' . t('Assignment points possible') . ' : ' . '</span>';
      $output .= '<span class = "gradebook-assignment-possible-points">' . $node->possible . '</span>';
      $output .= '</p>';
    }
    if (isset($node->due_date)) {
      $output .= '<p>';
      $output .= '<span class = "gradebook-assignment-due">' . t('This assignment is due on') . ' ' . '</span>';
      $output .= '<span class = "gradebook-assignment-due-date">'. format_date($node->due_date, 'custom', 'F j, Y');
      $output .= ' '. t('at') . ' ' . format_date($node->due_date, 'custom', 'h:i a') . '</span>';
      $output .= '</p>';
    }
    $output .= '</div>';
  }

  return $output;
}

/**
 * Prepares extra assignment fields for the node create forms.
 * Called via hook_form_alter.
 * @param $node
 *   The assignment node.
 *
 * @return $form
 *   Additional form array elements for the assignment create form.
 */
function gradebookapi_assignment_form_elements($node) {
  require_once('gradebook.datetime.inc');
  $form = array();
  // Store the old gradebook term id in case user changes category.
  $oldtax = isset($node->taxonomy) ? $node->taxonomy : NULL;
  $gradebook = NULL;
  if (is_array($oldtax)) {
    $vid = gradebookapi_get_vid();
    foreach ($oldtax as $term) {
      if ($term->vid == $vid) {
        $oldtid = $term->tid;
        $gradebook = gradebookapi_get_tid_gradebook($oldtid);
      }
    }
  }
  $form['gradebookapi'] = array(
    '#type' => 'fieldset',
    '#title' => t('Assignment Settings'),
    '#tree' => FALSE,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#weight' => 0,
    '#validate' => array('gradebookapi_assignment_validate' => array()),
  );
  $form['gradebookapi']['possible'] = array(
    '#type' => 'textfield',
    '#title' => t('Possible'),
    '#default_value' => (isset($node->possible) ? $node->possible : '0'),
    '#size' => 10,
    '#maxlength' => 10,
    '#required' => TRUE,
  );
  if (!isset($node->due_date)) {
    $node->due_date = strtotime(variable_get('gradebookapi_assignments_interval', '+1 month'));
  }

  if (!isset($node->publish_date)) {
    $node->publish_date = time();
  }

  $datetype = _gradebookapi_usedateapi() ? 'date_popup': 'date';

  $default = is_numeric($node->due_date) ?  (
             ($datetype == 'date_popup') ?
              _gradebookapi_unixtime2datepopup($node->due_date) : _gradebookapi_unixtime2drupaldate($node->due_date))
             : $node->due_date;

  $form['gradebookapi']['due_date'] = array(
    '#prefix' => '<div class="date_widget">',
    '#suffix' => '</div>',
    '#type' => $datetype,
    '#title' => t('Assignment due date'),
    '#default_value' => $default,
    '#date_label_position' => 'within',
    '#date_increment' => 15,
    '#date_year_range' => '-3:+3',
    '#date_format' => 'Y-m-d H:i',
  );

  if ($datetype == 'date') {
    // Include a time field element.
    $form['gradebookapi']['due_time'] = array(
      '#type' => 'test_time',
      '#title' => t('Due at'),
      '#default_value' => variable_get('due_time', array('hour' => 12, 'minute' => 0, 'meridiem' => 'pm')),
    );
  }
  $default = is_numeric($node->publish_date) ?  (
             ($datetype == 'date_popup') ?
             _gradebookapi_unixtime2datepopup($node->publish_date) : _gradebookapi_unixtime2drupaldate($node->publish_date))
             : $node->publish_date;

  $form['gradebookapi']['publish_date'] = array(
    '#prefix' => '<div class="date_widget">',
    '#suffix' => '</div>',
    '#type' => $datetype,
    '#title' => t('Publish date'),
    '#default_value' => $default,
    '#date_label_position' => 'within',
    '#date_increment' => 15,
    '#date_year_range' => '-3:+3',
    '#date_format' => 'Y-m-d H:i',
  );
  if ($datetype == 'date') {
    // Include a time field element.
    $form['gradebookapi']['publish_time'] = array(
      '#type' => 'test_time',
      '#title' => t('Publish time'),
      '#default_value' => variable_get('publish_time', array('hour' => 12, 'minute' => 0, 'meridiem' => 'pm')),
    );
  }
  $form['#submit'][] = 'gradebookapi_assignment_submit';
  if (isset($oldtid)) {
    $form['gradebookapi']['oldtid'] = array('#type' => 'hidden', '#value' => $oldtid);
  }
  return $form;
}

/**
 *  Implements hook_validate().
 *
 *  @param $node
 *    The assignment node.
 *  @param $form
 *    The $form parameter passed from node_validate.
 *
 *  @return NONE
 */
function gradebookapi_assignment_validate($node, $form = NULL) {
  require_once('gradebook.datetime.inc');
  if ($node) {
    if (_gradebookapi_usedateapi()) {
      $due_date =  _gradebookapi_datepopup2unixtime($node->due_date);
      $publish_date = _gradebookapi_datepopup2unixtime($node->publish_date);
    }
    else {
      $due_date = _gradebookapi_drupaldate2unixtime($node->due_date);
      $publish_date = _gradebookapi_drupaldate2unixtime($node->publish_date);
    }
    if ($publish_date >= $due_date) {
      form_set_error('publish_date', t('The publish date of an assignment must be before its due date.'));
    }
  }
}

/**
 * Implements hook_submit().
 * This checks if the assignment should be marked as published.
 */
function gradebookapi_assignment_submit($form, &$form_state) {
  require_once('gradebook.datetime.inc');
  if (_gradebookapi_usedateapi()) {
      $due_date = _gradebookapi_datepopup2unixtime($form_state['values']['due_date']);
      $publish_date = _gradebookapi_datepopup2unixtime($form_state['values']['publish_date']);
  }
  else {
    $due_date = _gradebookapi_drupaldate2unixtime($form_state['values']['due_date']);
    $publish_date = _gradebookapi_drupaldate2unixtime($form_state['values']['publish_date']);
  }

  $now = time();
  $form_state['values']['status'] = ($now >= $publish_date);
  if ($form_state['values']['status']) {
    drupal_set_message(t('The assignment is currently active.'));
  }
  else {
    drupal_set_message(t('The assignment will become active on !date.', array('!date' => format_date($publish_date, 'small'))));
  }
}

/**
 * Implements hook_form_alter().
 */
function gradebookapi_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type']['#value']) && $form['type']['#value'] .'_node_form' == $form_id) {
    $node = $form['#node'];
    $types = gradebookapi_get_assignment_types();

    // Is this an assignment type?
    if (!empty($types)) {
      if (in_array($node->type, $types)) {
        $form += gradebookapi_assignment_form_elements($node);
      }
    }
  }
}

/**
 * Implements hook_nodeapi().
 */
function gradebookapi_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  $types =(array)gradebookapi_get_assignment_types();
  if (in_array($node->type, $types)) {
    switch ($op) {
      case 'load':
        return gradebookapi_assignment_load($node);
      case 'insert':
        gradebookapi_assignment_insert($node);
        break;
      case 'update':
        gradebookapi_assignment_update($node);
        break;
      case 'delete':
        gradebookapi_assignment_delete($node);
        break;
      case 'view':
        gradebookapi_assignment_view($node, $a3, $a4);
        break;
      case 'validate':
        gradebookapi_assignment_validate($node, $a3);
        break;
    }
  }
}

/**
 * Determines whether a user is either a student or teacher for a given gradebook.
 * Used to control access to gradebook content.
 *
 * @param $gradebook
 *   The gradebook object.
 * @param $account
 *   The user object.
 *
 * @return
 *   TRUE if $account is a student, teacher or has uid=1, FALSE otherwise.
 */
function gradebookapi_is_student_or_teacher($gradebook = NULL, $account = NULL) {
  if (gradebookapi_is_student($gradebook, $account)) {
    return TRUE;
  }
  elseif (gradebookapi_is_teacher($gradebook, $account)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Determines whether a user is a student for a given gradebook.
 * Used to control access to gradebook content.
 *
 * @param $gradebook
 *   The gradebook object.
 * @param $account
 *   The user object.
 *
 * @return
 *   TRUE if $account is a student or has uid=1, FALSE otherwise.
 */
function gradebookapi_is_student($gradebook = NULL, $account = NULL) {
  global $user;

  if (is_null($account)) {
    $account = user_load(array('uid' => $user->uid));
  }

  // User #1 has all privileges.
  if ($account->uid == 1) {
    return TRUE;
  }

  $students = gradebookapi_get_students($gradebook);
  if (in_array($account->uid, $students['uid'])) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Determines whether a user is a teacher for a given gradebook.
 * Used to control access to gradebook content.
 *
 * @param $gradebook
 *   The gradebook object.
 * @param $account
 *   The user object.
 *
 * @return
 *   TRUE if $account is a teacher or has uid=1, FALSE otherwise.
 */
function gradebookapi_is_teacher($gradebook = NULL, $account = NULL) {
  global $user;

  if (is_null($account)) {
    $account = user_load(array('uid' => $user->uid));
  }

  // User #1 has all privileges.
  if ($account->uid == 1) {
    return TRUE;
  }

  $teachers = gradebookapi_get_teachers($gradebook);
  if (in_array($account->uid, $teachers['uid'])) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Gradebook UI modules determine which users are students and teachers.
 *
 * This is done by defining a function hook_gradebookapi_students that returns an array of user ids.
 * The api calls all of these hook functions and merges the results into one array.
 *
 * @param $gradebook
 *   The gradebook object. If NULL, then return teachers from all gradebooks.
 *
 * @return
 *   An array of student user ids.
 */
function gradebookapi_get_students($gradebook = NULL) {
  $students = array();
  $modules = module_implements('gradebookapi_students');
  $gradebooks = is_null($gradebook) ? gradebookapi_get_all_gradebooks() : array($gradebook);
  foreach ($gradebooks as $gradebook) {
    foreach ($modules as $module) {
      $function = $module . '_gradebookapi_students';
      $students = $function($gradebook, $students);
    }
  }
  return $students;
}

/**
 * Gradebook UI modules determine which users are teachers.
 *
 * This is done by defining a function hook_gradebookapi_teachers that returns an array of user ids.
 * The api calls all of these hook functions and merges the results into one array.
 *
 * @param $gradebook
 *   The gradebook object. If NULL, then return teachers from all gradebooks.
 *
 * @return
 *   An array of teacher user ids.
 */
function gradebookapi_get_teachers($gradebook = NULL) {
  $teachers = array();
  $modules = module_implements('gradebookapi_teachers');
  $gradebooks = is_null($gradebook) ? gradebookapi_get_all_gradebooks() : array($gradebook);
  foreach ($gradebooks as $gradebook) {
    foreach ($modules as $module) {
      $function = $module . '_gradebookapi_teachers';
      $teachers = $function($gradebook, $teachers);
    }
  }
  return $teachers;
}

/**
 * Implements hook_cron().
 *
 * This function allows gradebookapi to insert its own actions when
 * the cron.php script is run, usually by the system cron system. This is useful
 * when performing periodic asynchronous tasks like, as in this case, checking to
 * see if any assignments should be published.
 *
 * @return
 *   Nothing.
 *
 * More detail at @link http://api.drupal.org/api/HEAD/function/hook_cron API page @endlink .
 */
function gradebookapi_cron() {
  $types = (array)gradebookapi_get_assignment_types();

  // Mark ready assignments as published.
  $sql = "UPDATE {node} SET status = 1 WHERE type IN ( '" . implode("', '", $types) . "') AND status = 0 AND nid IN (SELECT nid FROM {gradebookapi_assignment} WHERE publish_date <= %d)";
  $the_time = time();
  $query_result = db_query($sql, $the_time);
  //watchdog('gradebookapi', 'Checking assignment status using %sql at timestamp %time, returned %res.', array('%res' => $query_result, '%time' => $the_time, '%sql' => $sql), WATCHDOG_INFO);

}

/**
 * Modifies date formats and publishes node if past the publish date.
 *
 * @param $node
 *   The assignment node object.
 */
function _gradebookapi_assignment_status(&$node) {
  require_once('gradebook.datetime.inc');
  if (_gradebookapi_usedateapi()) {
    $node->publish_date = _gradebookapi_datepopup2unixtime($node->publish_date);
    $node->due_date = _gradebookapi_datepopup2unixtime($node->due_date);
  }
  else {
    $node->publish_date = _gradebookapi_drupaldate2unixtime($node->publish_date);
    $node->due_date = _gradebookapi_drupaldate2unixtime($node->due_date);
  }
  $now = time();
  $node->status = ($now > $node->publish_date) ? 1 : 0;
}

/**
 * Determines whether the date popup should be used to select a date.
 *
 * @return
 *   TRUE if the date popup module exists and the use dateapi option is enabled.
 */
function _gradebookapi_usedateapi() {
  return (module_exists('date_popup') && variable_get('gradebookapi_use_dateapi', FALSE));
}

/**
 * Gradebook UI modules provide marks to replace numerical grades.
 *
 * This is done by defining a function hook_gradebookapi_marks that returns a string of not
 * more than five characters. It only makes sense to take one mark.
 *
 * @param $gid
 *   The gradebook term id.
 * @param $aid
 *   The assignment id.
 * @param $gradepoints.
 *   The earned points for the assignment.
 * @param $refresh
 *   A flag. When set to TRUE, reloads the mark lookup table.
 *
 * @return
 *   The mark corresponding to the grade.
 */
function gradebookapi_load_marks($gid, $aid = -1, $gradepoints, $refresh = FALSE) {
  $mark = module_invoke_all('gradebookapi_marks', $gid, $aid, $gradepoints, $refresh);
  return array_pop($mark);
}

/**
 * Send email to teachers when gradebook response has changed to completed.
 *
 * @param $type
 *   A string indicating the type of email notice to send (either 'grade' or 'assignment').
 * @param $objs
 *   An array of objects to use to construct the mail message.
 */
function gradebookapi_send_email($type, $objs) {
  // Obtain the gradebook(s) for the assignment.
  $gradebooks = array();
  $terms = gradebookapi_assignment_terms($objs['assignment']);
  foreach ($terms as $term) {
    // Retrieves the gradebook for this term and checks to see if the user in the gradebook.
    $gradebooks[] = gradebookapi_get_tid_gradebook($term->tid);
  }
  $params = array();
  // The sender of the email is the logged in user.
  global $user;
  $params['sender'] = user_load(array('uid' => $user->uid));
  switch ($type) {
    case 'assignment':
      if (variable_get('gradebookapi_assignment_update_email_allowed', FALSE)) {
        $params['assignment'] = $objs['assignment'];
        // Notify all students in each gradebook for which this node is an assignment.
        foreach ($gradebooks as $gradebook) {
          $params['gradebook'] = $gradebook;
          $students = gradebookapi_get_students($gradebook);
          foreach ($students['uid'] as $uid) {
            $account = user_load(array('uid' => $uid));
            if ($account->assignment_update_email) {
              $params['recipient'] = $account;
              drupal_mail('gradebookapi', 
                          'gradebookapi_' . $type, 
                          $params['recipient']->mail,
                          user_preferred_language($params['recipient']),
                          $params,
                          $params['sender']->mail);
            }
          }
        }
      }
      break;
    case 'grade':
      if (variable_get('gradebookapi_grade_update_email_allowed', FALSE)) {
        // Load the student user account.
        $grade = $objs['grade'];
        $account = user_load(array('uid' => $grade->uid));
        if ($account->grade_update_email) {
          $params['recipient'] = $account;
          $params['gradebook'] = array_pop($gradebooks);
          $params['assignment'] = node_load($objs['grade']->nid);
          drupal_mail('gradebookapi',
                      'gradebookapi_' . $type,
                      $params['recipient']->mail,
                      user_preferred_language($params['recipient']),
                      $params,
                      $params['sender']->mail);
        }
      }
      break;
  }
}

/**
 * Implements hook_mail().
 */
function gradebookapi_mail($key, &$message, $params) {
  $sender = $params['sender'];
  $recipient = $params['recipient'];
  $assignment = $params['assignment'];
  $gradebook = $params['gradebook'];

  // Select the appropriate subject and body type based on the mail key.

  $subject = variable_get($key . '_update_email_subject', gradebookapi_email_format($key, 'subject'));
  $body = variable_get($key . '_update_email_body', gradebookapi_email_format($key, 'body'));

  $gradebookpath = 'gradebook/' . $gradebook->tid;
  $assignmentpath = 'node/' . $node->nid;

  $replace = array('%sender'       => $sender->name,
                   '%recipient'    => $recipient->name,
                   '%assignment'   => $assignment->title,
                   '%coursename'   => $gradebook->name,
                  '%assignmenturl' => url($assignmentpath, array('absolute' => TRUE)),
                   '%gradebookurl' => url($gradebookpath, array('absolute' => TRUE)),
                   '%sitename'     => variable_get('site_name', 'Drupal'),
                  );
  $message['subject']  = strtr($subject, $replace);
  $message['body'] = strtr($body, $replace);
}

/**
 * Returns the default email subject and body format for gradebookapi notifications.
 *
 * @param $type
 *   The type of email message to prepare, either 'assignment' or 'grade'.
 * @param $target
 *   The format string to return, either 'subject' or 'body'.
 *
 * @return
 *   A text string containing either the email subject or body format.
 */
function gradebookapi_email_format($type, $target) {
  $text = '';
  switch ($type) {
    case 'gradebookapi_grade':
      switch ($target) {
        case 'subject':
          $text = 'Your grade for %assignment has been assigned.';
          break;
        case 'body':
          $text = 'Dear %recipient, a grade has been assigned for the assignment %assignment on %sitename. You can view your grade by going to %gradebookurl.';
          break;
      }
      break;
    case 'gradebookapi_assignment':
      switch ($target) {
        case 'subject':
          $text = 'An assignment for %coursename has been published or updated.';
          break;
        case 'body':
          $text = 'Dear %recipient, an assignment named %assignment has been published on %sitename. You can view the assignment by going to %assignmenturl.';
          break;
      }
  }
  return $text;
}
